{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","date":"2019-05-14T03:07:25.098Z","path":"2019/05/14/Docker-01概念/","content":"<h1 id=\"Docker-01-Docker-是什么\"><a href=\"#Docker-01-Docker-是什么\" class=\"headerlink\" title=\"Docker-01 Docker 是什么\"></a>Docker-01 Docker 是什么</h1><h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><p>1.Docker是什么</p>\n<p>2.为什么使用Docker</p>\n<p>3.Docker的安装和使用</p>\n<h2 id=\"一、什么是Docker\"><a href=\"#一、什么是Docker\" class=\"headerlink\" title=\"一、什么是Docker\"></a>一、什么是Docker</h2><p>官方定义：Docker是世界领先的软件容器平台。是dotCloud开源的一个基于LXC（注：LXC又名Linux container，是一种虚拟化的解决方案，是内核级的虚拟化）的高级容器引擎，基于go语言并遵循Apache2.0协议，源码托管于GitHub。 </p>\n<h2 id=\"二、什么是容器\"><a href=\"#二、什么是容器\" class=\"headerlink\" title=\"二、什么是容器\"></a>二、什么是容器</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>容器</th>\n<th>虚拟机</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>启动</td>\n<td>秒</td>\n<td>分钟</td>\n</tr>\n<tr>\n<td>硬件使用</td>\n<td>MB</td>\n<td>GB</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>接近原生</td>\n<td>弱</td>\n</tr>\n<tr>\n<td>支持量级</td>\n<td>单机上千个</td>\n<td>几十个</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"1-虚拟机（寄居架构和裸金属架构）\"><a href=\"#1-虚拟机（寄居架构和裸金属架构）\" class=\"headerlink\" title=\"1.虚拟机（寄居架构和裸金属架构）\"></a>1.虚拟机（寄居架构和裸金属架构）</h3><p>#####■ 有自己的OS操作系统</p>\n<h5 id=\"■-独立于主机OS\"><a href=\"#■-独立于主机OS\" class=\"headerlink\" title=\"■ 独立于主机OS\"></a>■ 独立于主机OS</h5><p>#####■ 宿主型管理程序将虚机当作一个个进程运行在主机上</p>\n<p>#####■ 虚机内核可以和主机不同。</p>\n<p>#####宿主型管理应用程序有：</p>\n<p>#####■ 开源OpenStack的kvm</p>\n<p>#####■ VMware的vSphere</p>\n<p>#####■ 微软的Hyper-V</p>\n<p>#####■ Citrix的XenServer</p>\n<p>#####■ IBM的PowerVM</p>\n<p>#####■ Red Hat Enterprise Virtulization</p>\n<p>#####■ 华为FusionSphere</p>\n<h3 id=\"2-容器\"><a href=\"#2-容器\" class=\"headerlink\" title=\"2.容器\"></a>2.容器</h3><h4 id=\"容器之间共享主机的OS操作系统\"><a href=\"#容器之间共享主机的OS操作系统\" class=\"headerlink\" title=\"容器之间共享主机的OS操作系统\"></a>容器之间共享主机的OS操作系统</h4><h4 id=\"容器被当作一个进程运行在主机上\"><a href=\"#容器被当作一个进程运行在主机上\" class=\"headerlink\" title=\"容器被当作一个进程运行在主机上\"></a>容器被当作一个进程运行在主机上</h4><p>####容器引擎有：</p>\n<h5 id=\"■-Docker\"><a href=\"#■-Docker\" class=\"headerlink\" title=\"■ Docker\"></a>■ Docker</h5><p>#####■CoreOS rkt    </p>\n<h5 id=\"■Mesos-containerizer\"><a href=\"#■Mesos-containerizer\" class=\"headerlink\" title=\"■Mesos containerizer\"></a>■Mesos containerizer</h5><h3 id=\"容器就是将软件打包成标准化单元，以用于开发、交付和部署\"><a href=\"#容器就是将软件打包成标准化单元，以用于开发、交付和部署\" class=\"headerlink\" title=\"容器就是将软件打包成标准化单元，以用于开发、交付和部署\"></a>容器就是将软件打包成标准化单元，以用于开发、交付和部署</h3><h2 id=\"三、为什么使用Docker\"><a href=\"#三、为什么使用Docker\" class=\"headerlink\" title=\"三、为什么使用Docker\"></a>三、为什么使用Docker</h2><h4 id=\"■-团队开发、解决开发环境问题\"><a href=\"#■-团队开发、解决开发环境问题\" class=\"headerlink\" title=\"■  团队开发、解决开发环境问题\"></a>■  团队开发、解决开发环境问题</h4><p>####■   秒级甚至毫秒级的启动时间</p>\n<p>####■   方便应用的部署和迁移</p>\n<p>####■   持续集成、持续交付和部署</p>\n<p>####■   程序服务资源竞争的问题</p>\n<p>####■   服务器集群/节点 动态扩容 </p>\n<p>##四、Docker的安装使用</p>\n<h4 id=\"1-Docker的安装\"><a href=\"#1-Docker的安装\" class=\"headerlink\" title=\"1.Docker的安装\"></a>1.Docker的安装</h4><p>1.#yum install docker             #安装docker</p>\n<p>2.#systemctl start docker         #启动docker</p>\n<p>3.#systemctl enable docker     # 开机启动docker</p>\n<p>4.#docker info                  #查看docker信息</p>\n<h4 id=\"2-Docker的基本概念\"><a href=\"#2-Docker的基本概念\" class=\"headerlink\" title=\"2.Docker的基本概念\"></a>2.Docker的基本概念</h4><p>#####Docker 采用的是 Client/Server 架构，所以有必要了解Docker的几个基本概念：</p>\n<h5 id=\"■-Client（客户端）\"><a href=\"#■-Client（客户端）\" class=\"headerlink\" title=\"■ Client（客户端）\"></a>■ Client（客户端）</h5><h5 id=\"■-Server（daemon服务端）\"><a href=\"#■-Server（daemon服务端）\" class=\"headerlink\" title=\"■ Server（daemon服务端）\"></a>■ Server（daemon服务端）</h5><h5 id=\"■-镜像（Image）-操作系统分为内核和用户空间。\"><a href=\"#■-镜像（Image）-操作系统分为内核和用户空间。\" class=\"headerlink\" title=\"■ 镜像（Image） 操作系统分为内核和用户空间。\"></a>■ 镜像（Image） 操作系统分为内核和用户空间。</h5><p>对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支 持。而Docker镜像（Image），就相当于是一个root文件系统。</p>\n<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何 改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层 标记为该文件已删除。</p>\n<p>base 镜像：不依赖其他镜像，从 scratch 构建。其他镜像可以在这个基础上进行扩展。</p>\n<p> 新镜像从 base 镜像一层一层叠加生成的，每安装一个软件，就在现有镜像的基础上增加一层。如果多个 镜像从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像。</p>\n<p> 当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都 叫“镜像层”。 </p>\n<p>#####■ 容器（Container）</p>\n<h5 id=\"■-仓库（Repository）\"><a href=\"#■-仓库（Repository）\" class=\"headerlink\" title=\"■ 仓库（Repository）\"></a>■ 仓库（Repository）</h5><p>####3.Build，Ship，and Run    </p>\n<h5 id=\"■-Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。\"><a href=\"#■-Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。\" class=\"headerlink\" title=\"■ Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。\"></a>■ Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。</h5><p>#####■ Ship（运输镜像）：主机和仓库间运输，这里的仓库就像是超级码头一样。</p>\n<p>#####■ Run （运行镜像）：运行的镜像就是一个容器，容器就是运行程序的地方。</p>\n","tags":[]}]}